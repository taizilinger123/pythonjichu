[root@localhost encrypt]# cat  server_aes_new_db.py 
import socket
import threading
import mysql.connector
import logging
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes
from base64 import b64decode,b64encode
logging.basicConfig(level=logging.INFO)
logging.info("Server started and listening on port 8082...")

# Load server's private and public keys
with open("/root/encrypt/key_server/private_key.pem", "rb") as key_file:
    private_key_server = serialization.load_pem_private_key(
        key_file.read(),
        password=None,
    )

with open("/root/encrypt/key_server/public_key.pem", "rb") as key_file:
    public_key_server = serialization.load_pem_public_key(
        key_file.read()
    )

# def decrypt_with_private_key(private_key, encrypted_data, key_size):
#     decrypted = private_key.decrypt(
#     encrypted_data,
#     padding.PKCS1v15()
#     )
#     return decrypted

def decrypt_with_private_key(private_key, encrypted_data, key_size):
    decrypted_data = b''
    for i in range(0, len(encrypted_data), key_size):
        chunk = encrypted_data[i:i + key_size]

        # ??????????????
        if len(chunk) != key_size:
            chlen = len(chunk)
            print(f"size:{chlen} vvv: {key_size}")
            if i == len(encrypted_data) - len(chunk):
                # ?????????key_size??????
                decrypted_chunk = private_key.decrypt(
                    chunk,
                    padding.PKCS1v15()
                )
            else:
                raise ValueError("Ciphertext length must be equal to key size")
        else:
            decrypted_chunk = private_key.decrypt(
                chunk,
                padding.PKCS1v15()
            )
        decrypted_data += decrypted_chunk
    return decrypted_data


def encrypt_with_public_key(public_key, message):
    encrypted = public_key.encrypt(
        message,
        padding.PKCS1v15()
    )
    return encrypted

def sign_with_private_key(private_key, message):
    signature = private_key.sign(
        message,
        padding.PKCS1v15(),  # ?? PKCS1v15 ??
        hashes.SHA256()
    )
    return signature

def receive_full_message(client_socket, buffer_size=4096):
    data = b''
    while True:
        part = client_socket.recv(buffer_size)
        data += part
        if len(part) < buffer_size:
            break
    return data


def handle_client(client_socket):
    # Database connection setup
    db_conn = mysql.connector.connect(
        host="localhost",
        user="root",
        password="Lahmy1c!123",
        database="db"
    )
    # Create a cursor to interact with the database
    cursor = db_conn.cursor()
    try:
        # Receive encrypted request from client
        encrypted_request = receive_full_message(client_socket)
        print(f"Received encrypted request from client. Length: {len(encrypted_request)} bytes")
        print(encrypted_request)
        # Assuming RSA key size (e.g., 2048 bits / 256 bytes)
        rsa_key_size = private_key_server.key_size // 8
        print(f"size:{rsa_key_size}")
        print("rcv:",encrypted_request)
        # Decrypt the request using the server's private key
        decrypted_request = decrypt_with_private_key( private_key_server, b64decode(encrypted_request), rsa_key_size)
        print(f"Decrypted request: {decrypted_request}")

        # Assuming the decrypted request is in the format: UUID_c|timestamp_c|PubKey_c
        decrypted_parts = decrypted_request.split(b'|')
        uuid_c = decrypted_parts[0].decode('utf-8')
        timestamp_c = decrypted_parts[1].decode('utf-8')
        pubkey_c_pem = decrypted_parts[2]

        # Store the decrypted request details in the MySQL database
        # Ensure the table exists
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS client_requests (
            id INT AUTO_INCREMENT PRIMARY KEY,
            uuid_c VARCHAR(255) NOT NULL,
            timestamp_c VARCHAR(255) NOT NULL,
            pubkey_c TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """)
        db_conn.commit()
        cursor.execute(
            "INSERT INTO client_requests (uuid_c, timestamp_c, pubkey_c) VALUES (%s, %s, %s)",
            (uuid_c, timestamp_c, pubkey_c_pem.decode('utf-8'))
        )
        db_conn.commit()

        # Properly format the public key as PEM
        pubkey_c_pem_formatted = b"-----BEGIN PUBLIC KEY-----\n" + pubkey_c_pem + b"\n-----END PUBLIC KEY-----\n"
        # Deserialize the client's public key
        public_key_client = serialization.load_pem_public_key(pubkey_c_pem_formatted)
        #public_key_client = serialization.load_der_public_key(pubkey_c_pem)

        # Encrypt the UUID_c and timestamp_c with the client's public key
        #response_message = uuid_c.encode('utf-8') + b'|' + timestamp_c.encode('utf-8')
        response_message = "hello world".encode()
        encrypted_response = encrypt_with_public_key(public_key_client, response_message)
        print(f"Encrypted response: {encrypted_response}")
        response_str = b64encode(encrypted_response).decode('utf-8')
        print(f"encrypted_response (base64)   : {response_str}")

        # Sign the response with the server's private key 
        signature = sign_with_private_key(private_key_server, response_message)
        print(f"Generated signature: {signature}")
         
        # Convert the signature (bytes) to a Base64 encoded string
        signature_str = b64encode(signature).decode('utf-8')

        # Print the Base64 encoded signature
        print(f"Generated signature (Base64):   {signature_str}")

        # Send the encrypted response and signature back to the client
        client_socket.send(encrypted_response + b'|' + signature)
        print("Sent encrypted response and signature to client.")

    finally:
        cursor.close()
        db_conn.close()
        client_socket.close()

def start_server():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('0.0.0.0', 8082))
    server_socket.listen(5)

    print("Server started and listening on port 8082...")

    while True:
        client_socket, addr = server_socket.accept()
        print(f"Connection from {addr} has been established!")
        
        # Start a new thread for each client connection
        client_thread = threading.Thread(target=handle_client, args=(client_socket,))
        client_thread.start()

if __name__ == "__main__":
    start_server()
